#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <dlfcn.h>

#include "libgotoku.h"
#include "got_offsets.h"  // for GOT offsets generated by analyze_got_gen_header.py

static void *lib_handle = NULL;
/* Position Independent Executable(PIE): loaded executing binary's physical memory start address*/
static uintptr_t pie_base = 0;  // 

// function pointers for GOT entries
static void (*real_gop_up)();
static void (*real_gop_down)();
static void (*real_gop_left)();
static void (*real_gop_right)();
static void (*real_gop_fill[10])();
static void (*real_gop_show)();
static void *(*real_game_get_ptr)();
static int (*real_game_init)();
static gotoku_t *(*real_game_load)(const char *);

int board[9][9];
int original_board[9][9];

typedef struct move_s {
    int x, y, val;
} move_t;

move_t moves[1200];

int move_count = 0;
int _initialized = 0;

// void move_to(int x, int y) {
//     while (board->x < x) { gop_right(); board->x++; }
//     while (board->x > x) { gop_left();  board->x--; }
//     while (board->y < y) { gop_down();  board->y++; }
//     while (board->y > y) { gop_up();    board->y--; }
// }

// void fill_number(int num) {
//     switch(num) {
//         case 0: gop_fill_0(); break;
//         case 1: gop_fill_1(); break;
//         case 2: gop_fill_2(); break;
//         case 3: gop_fill_3(); break;
//         case 4: gop_fill_4(); break;
//         case 5: gop_fill_5(); break;
//         case 6: gop_fill_6(); break;
//         case 7: gop_fill_7(); break;
//         case 8: gop_fill_8(); break;
//         case 9: gop_fill_9(); break;
//     }
//     board->board[board->y][board->x] = num;
// }

int is_valid(int board[9][9], int row, int col, int num) {
    for (int i = 0; i < 9; i++) {
        if (board[row][i] == num || board[i][col] == num)
            return 0;
    }
    int box_row = row / 3 * 3;
    int box_col = col / 3 * 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[box_row + i][box_col + j] == num)
                return 0;
        }
    }
    return 1;
}
// int solve() {
//     for (int y = 0; y < 9; y++) {
//         for (int x = 0; x < 9; x++) {
//             if (board->board[y][x] == 0) {
//                 for (int num = 1; num <= 9; num++) {
//                     if (is_valid(y, x, num)) {
//                         move_to(x, y);
//                         fill_number(num);
//                         if (solve()) return 1;
//                         move_to(x, y);
//                         fill_number(0);
//                         board->board[y][x] = 0;
//                     }
//                 }
//                 return 0;
//             }
//         }
//     }
//     return 1;
// }

/*
    recursive solve sudoku function(dfs)
    solve from (0, 0) to (9,9) row-major
*/
int solve_sudoku(int board[9][9], int row, int col) {
    if(row == 9) return 1;
    if(col == 9) return solve_sudoku(board, row + 1, 0);
    if(board[row][col] != 0) return solve_sudoku(board, row, col + 1);
    for(int num = 1; num <= 9; num++) {
        if(is_valid(board, row, col, num)) {
            board[row][col] = num;
            if(solve_sudoku(board, row, col + 1)) return 1;
            board[row][col] = 0;  // if not solve, backtrack
        }
    }
    return 0;
}

void generate_moves() {
    int cursor_x = 0, cursor_y = 0;
    for(int y = 0; y < 9; y++) {
        for(int x = 0; x < 9; x++) {
            if(original_board[y][x] == 0 && board[y][x] != 0) {
                // move cursor to the right position
                while(cursor_y < y){
                    moves[move_count++] = (move_t){0, 1, 0};
                    cursor_y++;
                }
                while(cursor_y > y){
                    moves[move_count++] = (move_t){0, -1, 0};
                    cursor_y--;
                }
                while(cursor_x < x){
                    moves[move_count++] = (move_t){1, 0, 0};
                    cursor_x++;
                }
                while(cursor_x > x){
                    moves[move_count++] = (move_t){-1, 0, 0};
                    cursor_x--;
                }
                // fill the value
                moves[move_count++] = (move_t){0, 0, board[y][x]};
            }
        }
    }
    // 印出所有 moves
    // printf("Generated moves (count: %d):\n", move_count);
    // for (int i = 0; i < 20; i++) {
    //     printf("Move %3d: x=%2d, y=%2d, val=%d\n", i, moves[i].x, moves[i].y, moves[i].val);
    // }
}

void hijack_gop_N_got() {
    // printf("Inside hijack_gop_N_got\n");
    // hijack gop_N GOT entry to our own function
    for(int i = 0; i < move_count; i++) {
        // printf("I'm here");
        // if (i >= sizeof(gop_got_offsets) / sizeof(gop_got_offsets[0])) {
        //     // fprintf(stderr, "patch_got: Exceeded gop_got_offsets size at i=%d\n", i);
        //     exit(1);  // 或 break;
        // }
        uintptr_t addr = pie_base + gop_got_offsets[i];
        // printf("gop_got_offsets[%d] = %p\n", i, (void *)addr);
        if(moves[i].val > 0 && moves[i].val <= 9) {
            char sym[32];
            snprintf(sym, sizeof(sym), "gop_fill_%d", moves[i].val);
            // printf("✔ %s = %p\n", sym, (void *)real_gop_fill[moves[i].val]);
            *(void **)(addr) = (void *)real_gop_fill[moves[i].val];
        } else if (moves[i].x == 1) {
            // printf("✔ gop_right = %p\n", (void *)real_gop_right);
            *(void **)(addr) = (void *)real_gop_right;
        } else if (moves[i].x == -1) {
            // printf("✔ gop_left = %p\n", (void *)real_gop_left);
            *(void **)(addr) = (void *)real_gop_left;
        } else if (moves[i].y == 1) {
            // printf("✔ gop_down = %p\n", (void *)real_gop_down);
            *(void **)(addr) = (void *)real_gop_down;
        } else if (moves[i].y == -1) {
            // printf("✔ gop_up = %p\n", (void *)real_gop_up);
            *(void **)(addr) = (void *)real_gop_up;
        }
    }
}
/* 
    Use mprotect to change the memory protection of the GOT page
    Make GOT allow writing
*/
void mprotect_got() {
    size_t page_size = sysconf(_SC_PAGESIZE);
    // printf("mprotect_got: page_size = %zu\n", page_size);
    // make got page to align 4kb(1 page)
    // uintptr_t got_page = (pie_base + gop_got_offsets[0]) & ~(0x1000 - 1);
    // printf("mprotect_got: got_page = %p\n", (void *)got_page);
    // uintptr_t start_page = pie_base & ~(page_size - 1);
    uintptr_t start_page = (pie_base + MINEST_GOT_OFFSET) & ~(page_size - 1);
    // printf("mprotect_got: start_page = %p\n", (void *)start_page);
    size_t desired_size = 0x3000;  // 192kB
    size_t size = ((desired_size + page_size - 1) / page_size) * page_size;
    // make 3 pages writable
    /*
        Each got entry is 8 bytes, there are 1200 entries
        total size = 1200 * 8 = 9600 bytes
        9600 bytes ~= 2.3 pages < 3 pages
    */
    mprotect((void *)start_page, size, PROT_READ | PROT_WRITE);
}


int prepare_funcs() {
    lib_handle = dlopen("libgotoku.so", RTLD_LAZY);
    if (!lib_handle) {
        fprintf(stderr, "[!] dlopen failed: %s\n", dlerror());
        return -1;
    }
    printf("SOLVER: libgotoku.so loaded at %p\n", lib_handle);
    real_gop_up = dlsym(lib_handle, "gop_up");
    if (!real_gop_up){
        fprintf(stderr, "[!] dlsym gop_up failed: %s\n", dlerror());
        return -1;
    }
    // printf("[+] real_gop_up = %p\n", real_gop_up);
    real_gop_down = dlsym(lib_handle, "gop_down");
    if (!real_gop_down) {
        fprintf(stderr, "[!] dlsym gop_down failed: %s\n", dlerror());
        return -1;
    }
    // printf("[+] real_gop_down = %p\n", real_gop_down);
    real_gop_left = dlsym(lib_handle, "gop_left");
    if (!real_gop_left) {
        fprintf(stderr, "[!] dlsym gop_left failed: %s\n", dlerror());
        return -1;
    }
    // printf("[+] real_gop_left = %p\n", real_gop_left);
    real_gop_right = dlsym(lib_handle, "gop_right");
    if (!real_gop_right) {
        fprintf(stderr, "[!] dlsym gop_right failed: %s\n", dlerror());
        return -1;
    }
    // printf("[+] real_gop_right = %p\n", real_gop_right);
    real_gop_show = dlsym(lib_handle, "gop_show");
    if (!real_gop_show) {
        fprintf(stderr, "[!] dlsym gop_show failed: %s\n", dlerror());
        return -1;
    }
    real_game_get_ptr = dlsym(lib_handle, "game_get_ptr");
    if (!real_game_get_ptr) {
        fprintf(stderr, "[!] dlsym game_get_ptr failed: %s\n", dlerror());
        return -1;
    }

    real_game_init = dlsym(lib_handle, "game_init");
    if (!real_game_init) {
        fprintf(stderr, "[!] dlsym game_init failed: %s\n", dlerror());
        return -1;
    }
    for (int i = 0; i <= 9; i++) {
        char sym[32];
        snprintf(sym, sizeof(sym), "gop_fill_%d", i);
        real_gop_fill[i] = dlsym(lib_handle, sym);
        if(!real_gop_fill[i]) {
            fprintf(stderr, "[!] dlsym %s failed: %s\n", sym, dlerror());
            return -1;
        }
        // printf("[+] real_gop_fill[%d] = %p\n", i, real_gop_fill[i]);
    }
    real_game_load = dlsym(lib_handle, "game_load");
    if (!real_game_load) {
        fprintf(stderr, "[!] dlsym game_load failed: %s\n", dlerror());
        return -1;
    }
    return 0;
}



int game_init() {
    printf("UP113_GOT_PUZZLE_CHALLENGE\n");
    int ret = prepare_funcs();
    if (ret != 0) {
        fprintf(stderr, "[!] prepare_funcs failed\n");
        return -1;
    }
    void* main_addr = real_game_get_ptr();
    printf("SOLVER: _main = %p\n", (void *)main_addr);
    pie_base = (uintptr_t)main_addr - MAIN_OFFSET;
    mprotect_got();
    return real_game_init();
}

gotoku_t *game_load(const char *filename) {
    gotoku_t *real_board = real_game_load(filename);
    if (real_board) {
        for (int y = 0; y < 9; ++y){
            for (int x = 0; x < 9; ++x){
                board[y][x] = real_board->board[y][x];
                original_board[y][x] = real_board->board[y][x];
            }
        }
    }
    solve_sudoku(board, 0, 0);
    // printf("SOLVER: solved board:\n");
    // for(int y = 0; y < 9; y++){
    //     for(int x = 0; x < 9; x++){
    //         printf("%d ", board[y][x]);
    //     }
    //     printf("\n");
    // }
    generate_moves();
    printf("SOLVER: moves count = %d\n", move_count);
    hijack_gop_N_got();
    // printf("SOLVER: game_load(%s) = %p\n", filename, real_board);
    return real_board;
}

